# STEP 4-2
==========

현재의 로직에서 서버가 스케일 아웃되면, replica DB 를 도입하게 되면 생기는 문제를 고민해주세요.
-------------

***

## 목차🧭

- [개요](#개요)
- [현재 상황](#현재-상황)
- [To-Be 상황](#도입-후)
- [주요 문제점](#주요-문제점)
- [해결 방안](#해결-방안)
***

## 개요📜

>서버가 스케일 아웃되고 레플리카 db 를 도입할 때 발생할 수 있는 문제점들을 검토합니다.

***   

## 현재 상황🖼️

>현재는 단일 서버와 단일 db 구성으로 운영되고 있습니다.  
>모든 읽기/쓰기 작업이 하나의 db 에서 처리됩니다.  
***

## 도입 후🔄

>서버가 부하에 따라 scale in/out 되면서, 여러 서버가 동시에 동작할 수 있습니다.  
>db 레플리카를 도입하여, 읽기 작업을 분산하여 처리할 수 있습니다.

## 주요 문제점⚠️

### 1. 데이터 일관성 문제
- **replication lag**: master 와 replica 간 데이터 동기화 지연으로 인한 데이터 불일치 발생 가능성
- **분산 트랜잭션**: 여러 서버에 걸친 트랜잭션에 대한 일관성 보장이 어려움
- **key 충돌**: 각 서버가 독립적으로 생성하는 key 값의 충돌 발생 가능성 존재

### 2. 모니터링 및 로깅 복잡성
- **로그 분산**: 여러 서버에 분산된 로그의 통합 분석이 복잡해짐

### 3. 애플리케이션 코드 수정
- **db connection**: 읽기/쓰기 분리에 따른 애플리케이션 코드 변경 가능성
- **분산 락(lock)**: 동시성 제어를 위한 분산 락 메커니즘 구현이 필요해질 수 있음

### 4. 인프라 운영, 관리 복잡성
- **배포 프로세스**: 여러 서버에 걸친 배포 자동화 및 롤백 전략 필요
- **설정 관리**: 서버별 설정의 일관성 유지 및 중앙화된 관리 필요
***

## 해결 방안💡

### **데이터 일관성 문제**
- **replication lag**: 서비스의 특성을 파악하여 지연을 어느정도 허용할 수 있는지 결정 후, 일관성 모델 선택 및 적용
- **분산 트랜잭션**: 2pc, saga 패턴 등의 분산 트랜잭션 처리 방안 검토
- **key 충돌**: UUID, ULID, snowflake id 등의 key 생성 전략 적용

### **모니터링 및 로깅 복잡성**
- **로그 분산**: 각 서버별로 발생하는 로그에 대한 trace id, machine id 등을 통해 통합 로깅 및 분석

### **애플리케이션 코드 수정**
- **db connection**: cqrs 패턴 적용을 통한 읽기/쓰기 분리 적용 가능
- **분산 락(lock)**: redis, zookeeper 등의 분산 락 메커니즘 적용

### **인프라 운영, 관리 복잡성**
- **배포 프로세스**: rolling-update 등의 배포 전략 적용. scale in/out 에 대해 alb(application load balancer), auto-scaling 적용
- **설정 관리**: machine image, launch template 등을 통한 공통된 서버 설정 관리. s3 혹은 efs nas 연결 방식을 통한 설정 파일 공유